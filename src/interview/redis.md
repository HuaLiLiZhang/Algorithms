## Redis
- redis单线程消费，怎么将结果原路返回？（套接字事件与redis的处理器相关联，哪个套接字发出的命令，命令回复处理器就返回给哪个套接字）
- Redis的性能瓶颈（机器内存和网络带宽，执行命令分 发送 排队 执行 返回  四个阶段，后者可以用打包多次命令，一次发送方法部分解决）
- Redis有哪些数据结构（sds，压缩表ziplist，链表linkedlist，字典hashtable，整数集合intset，跳表skiplist）
- 布隆过滤器怎么实现（bitmap和Redisson）
- redis从库查询过期键（不会主动删除，等主库的del命令，会一段时间那还能访问，但3.2以上版本会先判断是否过期，过期返回null）
- Redis的lua脚本为何是原子的（redis会为lua脚本执行创建伪客户端模拟客户端调用redis执行命令，伪客户端执行lua脚本是排他的）


### Redis pipeline为什么能提升大批量数据插入的效率
普通命令经历四个阶段：1）发送命令－〉（2）命令排队－〉（3）命令执行－〉（4）返回结果
pipeline管道机制，它能将一组Redis命令进行组装，通过一次RTT传输给Redis，并将这组Redis命令的执行结果按顺序返回给客户端


### redis过期策略
1. 定时策略：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除
- 优点：保证内存被尽快释放，减少无效的缓存暂用内存
- 缺点：若过期key很多，删除这些key会占用很多的CPU时间；定时器很多，影响性能，一般不选这种
2. 惰性策略：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null
- 优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的
- 缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，此时的无效缓存是永久暂用在内存中的，那么可能发生内存泄露
3. 定期策略：每隔一段时间对设置了缓存时间的key进行检测，如果可以已经失效，则从内存中删除，如果未失效，则不作任何处理（随机取key，不遍历所有key）
- 优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理"定时删除"的缺点；定期删除过期key--处理"惰性删除"的缺点
- 缺点：在内存友好方面，不如"定时删除"，因为是随机遍历一些key，因此存在部分key过期，但遍历key时，没有被遍历到，过期的key仍在内存中。在CPU时间友好方面，不如"惰性删除"，定期删除也会暂用CPU性能消耗。

### 缓存和数据库一致性怎么解决（https://xie.infoq.cn/article/47241d099404a1565e168fad4）
#### 前提讨论（缓存用删除而不是更新，防止多线程竞争）
1. 先删除缓存，再更新数据库
- 可能导致数据不一致，同时有一个请求 A 进行更新操作，另一个请求 B进行查询操作。那么会出现如下情形:
（1）请求 A 进行写操作，删除缓存
（2）请求 B 查询发现缓存不存在
（3）请求 B 去数据库查询得到旧值
（4）请求 B 将旧值写入缓存
（5）请求 A 将新值写入数据库
- 此时缓存中是旧值，若不采用给缓存设置过期时间策略，该数据永远都是脏数据
2. 先更新数据库，再删除缓存
- 也可能导致数据不一致，一个请求 A 做查询操作，一个请求 B做更新操作，那么会有如下情形产生
（1）缓存刚好失效
（2）请求 A 查询数据库，得一个旧值
（3）请求 B 将新值写入数据库
（4）请求 B 删除缓存
（5）请求 A 将查到的旧值写入缓存
- 一般不会发生，理由是（3）写数据库更耗时，大多数情况下采用这种


#### 解决方案
1. 缓存延时双删：先淘汰缓存，再更新数据库，等1s后再次淘汰缓存（第二次可以异步以增加吞吐量）
2. 重试机制：解决缓存删除失败的情况
- 缓存删除失败后，把请求放入MQ，再消费MQ重试之
- 非侵入的代码，订阅binlog，做重试删除缓存

### bitmap可以做什么
bitmap是通过一个bit数组来存储特定数据的一种数据结构，最大可以存放2的32次方（512MB）
1. 可以用于排序，如1 2 3 5 7 可以用1B的数据，8位分别代表0-7，有则置1，最后遍历即可
2. 员工打卡记录，SETBIT key offset value结合GETBIT命令查看某人是否打卡，结合BITCOUNT查看某天打卡总人数


### 分布式限流器怎么实现
1. 令牌桶：一定大小的桶，每隔一段时间往里面放令牌（直到满），每个请求拿k个，拿完之后后面的请求拒绝
- Google的Guava

2. 漏斗桶：通过一个 FIFO （First in first out）的队列（有界）实现，如果请求堆积满了队列，就会触发丢弃策略。消费者以一定的速率消化这些请求
3. 固定时间窗口（Fixed window）：将时间切分成若干个时间片，每个时间片内固定处理若干个请求。假设n秒内最多处理b个请求，那么每隔n秒将计数器重置为b。请求到来时，如果计数器值足够，则扣除并请求通过，不够则触发拒绝策略。
- 缺陷：请求都在时间窗口的开头被迅速消耗，剩下的时间不处理任何请求
4. 滑动日志（Sliding Log）：滑动日志根据缓存之前接受请求对应的时间戳，与当前请求的时间戳进行计算，控制速率。这样可以严格限制请求速率。假设n秒内最多处理b个请求。那么会最多缓存 b 个通过的请求与对应的时间戳，假设这个缓存集合为B。每当有请求到来时，从B中删除掉n秒前的所有请求，查看集合是否满了，如果没满，则通过请求，并放入集合，如果满了就触发拒绝策略。
5. 滑动窗口（滑动日志 + 固定窗口）：假设n秒内最多处理b个请求。我们可以将n秒切分成每个大小为m毫秒得时间片，只有最新的时间片内缓存请求和时间戳，之前的时间片内只保留一个请求量的数字。这样可以大大优化存储，小幅度增加计算量。

#### 分布式限流
在redis上配置限流器，每个节点收到来自上游的请求后直接请求数据库，然后数据库根据限流器判断是否处理这个请求，最后返回给节点相关信息。如果请求量大，redis负载较高
1. 在节点上积攒够一定的请求量N后再去请求中心限流器，这样节点对中心化数据库的请求频次会降低为1/N。
- 缺点：请求积攒阶段这些请求就无法决定是否被处理，这样也会造成一定的延迟增加。并且如果请求十分不均匀，在积攒阶段迟迟攒不到N个，即使设置了积攒超时也会大大增加延迟
2. 认为负载均衡器会将流量十分均匀的分布在各个节点上，这样本地限流器的配置就等于全局限流器的配置除以节点数量
- 缺点：对中心化数据库的压力更小，但误差也更大，负载均衡器并不能保证流量会十分均匀地打到各个节点上，其次中心化数据库也可能对活着的节点数量统计不准确
3. 每个节点初始时请求中心限流器N个令牌，当N个令牌都消耗完了再去数据库请求N个
- 只针对令牌算法，有一定的误差


### 布隆过滤器在Redis中的应用
一个大的bit数组，几个hash函数，对健key，通过几个hash函数，计算得第k位是否为1，如果判断结果都为否，则肯定不存在；判断存在则只是可能存在
适用于：邮件&网站黑名单，新闻推荐去重，恶意攻击导致的缓存穿透，查询加速（缓存不存在再访问磁盘）

是否适合百万级别手机号和url的判断


### 什么是缓存雪崩、缓存击穿、缓存穿透？
1. 雪崩
- 如果缓在某一个时刻出现大规模的key失效，那么就会导致大量的请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。
- 原因：redis宕机，采用相同的过期时间
- 解决：1. 过期时间不是同一个  2. 分级缓存，每一级缓存过期时间不同  3. 热点数据缓存永不过期（不设置过期时间或借助value延时） 4. 主从哨兵或集群保证高可用
2. 击穿
- 缓存击穿是某个热点的key失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。
- 解决：1. 永不过期  2. 缓存失效后，通过互斥锁或队列控制数据写缓存的线程数量，如某个key只 允许一个线程访问，其他阻塞等待
3. 穿透
- 指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。
- 解决：1. 布隆过滤器：数据库中的所有key存放在布隆过滤器中，不存在直接返回  2. 无效的key存放入redis中，value为null（不能解决随机key问题）



### 跳表怎么实现的 ，为何不用红黑树，跳表有何优势，时间复杂度是多少
不用红黑树：1. 复杂度一样，实现更简单  2. zrange更方便  3. 更少的内存占用（可以少一些层） 
实现：层（随机生成1-32的数，数越大，出现几率越小），前进指针，后退指针，跨度（记录两个节点之间的距离），分值和对象
时间复杂度：插入、删除平均为log(n)，最坏是O(n)


### sds怎么实现的
1. len记录长度，free未用长度和buf[]存放字符，尾部也要加\0
2. 杜绝缓冲区溢出：先检查SDS的空间是否满足修改的需求，若不满足，则API会自动将SDS的空间扩展以至于能够放下src
3. 减少修改字符串时带来的内存重分配次数：
- C语言在字符串增长操作前，要先扩容，否则会发生缓冲区溢出字符串缩长操作前，要先释放空间，否则会内存泄露
- 空间预分配：在对SDS增长时，检查free够不够用，不够用触发扩容若增长后len小于1M，则分配free = len的额外空间若len 大于1M，则分配free = 1M的额外空间
- 惰性空间释放：对SDS缩短时，把空闲空间记录在free中，并不释放
4. 二进制安全：
- C字符串存在二进制安全的问题，它职能保存文本数据，而不能保存像图片、音频、视频压缩文件等二进制数据，因为遇到'\0'就是一个结束了的C字符串。
- 而SDS的API都是二进制安全的，所有API以处理二进制的方式来处理SDS存放的buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者转义，数据在写入时是怎么样的，被读取时就是什么样。这也是将SDS的buf数组叫做字节数组的原因——Redis不是用这个数组来保存字符，而使用它来直接保存二进制数据。


### Redis如何做分布式锁以及和zk锁的区别
#### Redis的锁
1. setNX（set if not exist）或set key value nx px 2000，其中px用来指定过期时间。
2. redlock解法：在大半的节点获取分布式锁，如果获取时间小于锁过期时间，代表获取锁成功。否则创建失败，依次删除锁（防止加锁请求发送成功，结果返回丢失）。如果别人已经建立了，就不断轮询获取锁
3. 开源框架Redission
 - 所有指令通过Lua脚本执行，Redis执行Lua脚本是原子的
 - 利用WatchDog概念，会在获取锁之后，每隔1/3（如10s）的过期时间就把锁的过期时间延长（每过10s过期时间延长至30s）。比不设置超时时间的好处是当宕机之后，看门狗消失，30s后锁过期，其他进程就能再获取锁了
 
### zk的一致性
- zk不保证强一致性，只保证顺序一致，若于强一致，比最终一致强得多
- zk的写是线性一致（强一致）的，换句话说，每次写入将在客户端发出请求和接收相应响应之间的某个时间点自动生效。
- zk的读不需要仲裁，直接返回，可能会读到旧数据

#### zk的锁
1. 每个线程获取锁就是在 ZK 创建一个临时有序的节点，比如在 /lock/ 目录下
2. 创建成功后，获取/lock下所有临时节点，判断当前线程创建的节点是否是序号最小的
3. 最小的线程获取锁成功，其他线程对前一个节点添加事件监听，锁释放后会对下一个节点进行唤醒，然后重复2

#### 区别
1. 服务端性能
- zk基于Zab协议，需要一半的节点ACK，才算写入成功，吞吐量低
- Redis基于，只写master就算成功，吞吐量高
2. 客户端性能
- Zk由于有通知机制，获取锁的过程，添加一个监听器。避免了轮询，性能消耗小
- Redis并没有通知机制，只能使用类似CAS的轮询，对客户端压力较大
3. 可靠性
- redis追求吞吐量，可靠性上稍逊，即使用了Redlock，在极端情况下也不能保证一致性
- zk有zab协议控制数据的一致性



### 如何解决redis热点key问题
自己统计，提前预热等，加入二级缓存或集群备份key解决
京东hotkey也可以解决

### Redis为什么快，为什么能达到10w qps
- 基于内存操作
- IO多路复用技术
- 单线程处理网络请求（6.0新增多线程）
- 使用管道能增加qps
- 其他业务会再fork新进程处理，如rehash，写日志等