## 区间和的个数解法
### 题目

给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。
区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。

说明:
最直观的算法复杂度是 O(n2) ，请在此基础上优化你的算法。

示例:

输入: nums = [-2,5,-1], lower = -2, upper = 2,
输出: 3
解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。



### 考虑
1. 题目中要求的S(i,j) 的和包含在lower和upper之间，第一步可以考虑求其前i项和，组成一个数组，如此S(i,j)就转化为求sums[j] - sums[i-1]
2. 直观求出每个(i,j)组合，时间复杂度过高
3. 若sums数组转化为有序（O(nlgn)排序），之后的问题就转化为在有序数组中求lower <= sums[j] - sums[i] <= upper，可以参考平衡树（https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E6%A0%91）
4. 第3步要引入复杂的数据结构，面试中很难一次想到并且写对。可以考虑部分有序时的情景，即归并排序中的merge部分。

### 解法
1. 先计算前i项和数组sums，注意sums是long类型，以免越界（有大数的测试用例）
2. 考虑利用归并排序，每次merge的阶段，左边数组[start,mid]和右边数组[mid+1,end]
3. 对左边的每个候选值i，找出右边数组中候选值low和up，满足lower <= sums[low] - sums[i]和sums[up] - sums[i] > upper，其中low和up为满足上诉不等式的第一个候选值
4. up - low即为候选值i满足要求的个数

### 注意的坑
1. 本解法简单的版本是归并时区间[start,end]，前后边界都包含，避免指针越界等异常
2. 统计过程中不要忘记正常的归并排序
3. 求和数组要用long类型，防止测试用例中有两个Integer.MAX_VALUE相加导致int越界

### 复杂度
1. 时间复杂度：O(nlgn)，归并排序中顺便同时统计目标个数，时间复杂度不高于归并排序
2. 空间复杂度：O(n)，归并排序的辅助数组
